<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organogram & Mind Map Builder</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --sidebar-width: 60px;
            --grid-size: 20px;
            --grid-color: #e0e0e0;
            --primary-color: #3b82f6;
            --selection-color: #2563eb;
            --delete-color: #ef4444;
            --active-color: #dbeafe;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            height: 100vh;
            width: 100vw;
        }

        #header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background-color: white;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        #project-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #334155;
            outline: none;
            padding: 5px 15px;
            border-radius: 4px;
            transition: background 0.2s;
            cursor: text;
        }

        #project-title:hover,
        #project-title:focus {
            background-color: #f1f5f9;
        }

        #app-body {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Sidebar Styles */
        #sidebar {
            width: var(--sidebar-width);
            background-color: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 70px 0 10px 0;
            /* Padding for header */
            gap: 10px;
            z-index: 2000;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
        }

        .tool-btn {
            width: 45px;
            height: 45px;
            min-height: 45px;
            border-radius: 8px;
            border: 1px solid #eee;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .tool-btn:hover {
            background-color: #f8fafc;
            border-color: #cbd5e1;
            transform: translateY(-1px);
        }

        .tool-btn.active {
            background-color: var(--active-color);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* Tooltip */
        .tool-btn[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 9999;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Only show tooltip if NOT interacting with a child popup */
        .tool-btn:hover::after {
            opacity: 1;
        }

        /* Hide tooltip if the tool-btn has a child that is display block (open slider) */
        .tool-btn.slider-open::after {
            display: none;
        }

        .tool-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 2;
            fill: none;
        }

        .color-picker-wrapper {
            position: relative;
        }

        .color-input {
            width: 100%;
            height: 100%;
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            cursor: pointer;
        }

        .color-preview {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .divider {
            width: 80%;
            height: 1px;
            min-height: 1px;
            background-color: #eee;
            margin: 5px 0;
        }

        /* Sliders Popover */
        .slider-popover {
            position: absolute;
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 150px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            border: 1px solid #ddd;
            display: none;
            z-index: 10000;
            /* Very high z-index */
        }

        .slider-popover input {
            width: 100%;
            margin: 0;
        }

        /* Canvas Styles */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            height: 100%;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        /* Format Painter Custom Cursor */
        body.format-painter-mode #canvas-container,
        body.format-painter-mode .node {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 22H4a2 2 0 0 1-2-2V6"/><path d="M10 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-8"/><rect x="10" y="2" width="12" height="12" rx="2"/></svg>') 0 24, crosshair !important;
        }

        #world {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            width: 0;
            height: 0;
        }

        #grid-pattern {
            position: absolute;
            top: -50000px;
            left: -50000px;
            width: 100000px;
            height: 100000px;
            background-image: radial-gradient(var(--grid-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            pointer-events: none;
            z-index: -1;
        }

        #connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            pointer-events: none;
            z-index: 0;
        }

        /* Node Styles */
        .node {
            position: absolute;
            min-width: 100px;
            min-height: 50px;
            background-color: white;
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 0;
            /* Changed from 10px to handle title bar */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            cursor: grab;
            display: flex;
            flex-direction: column;
            z-index: 10;
            user-select: none;
            transition: box-shadow 0.2s, transform 0.1s;
        }

        .node:active {
            cursor: grabbing;
        }

        /* Resize Handles */
        .resizer {
            position: absolute;
            z-index: 35;
            background: transparent;
        }

        .resizer-r {
            top: 0;
            right: -5px;
            width: 10px;
            height: 100%;
            cursor: col-resize;
        }

        .resizer-b {
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 10px;
            cursor: row-resize;
        }

        .resizer-rb {
            bottom: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            cursor: nwse-resize;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .node:hover .resizer-rb,
        .node.selected .resizer-rb {
            opacity: 1;
        }

        .node.selected {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
            z-index: 20;
        }

        .node-title-bar {
            width: 100%;
            padding: 4px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid #ccc;
            flex-shrink: 0;
            min-height: 1.5em;
            border-radius: 6px 6px 0 0;
            /* Match node border-radius */
        }

        .node-title {
            width: 100%;
            text-align: center;
            outline: none;
            font-weight: bold;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .node-content {
            width: 100%;
            flex-grow: 1;
            padding: 10px;
            outline: none;
            word-wrap: break-word;
            white-space: pre-wrap;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .node.editing .node-content,
        .node.editing .node-title {
            cursor: text;
        }

        /* Add Child Button */
        .add-child-btn {
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 24px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 40;
            font-size: 18px;
            line-height: 1;
        }

        .node:hover .add-child-btn,
        .node.selected .add-child-btn {
            opacity: 1;
        }

        .add-child-btn:hover {
            transform: translateX(-50%) scale(1.1);
        }

        /* SVG Line Styles */
        .connection-line {
            fill: none;
            stroke: #94a3b8;
            stroke-width: 2px;
            stroke-linecap: round;
        }

        /* Controls Overlay */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            padding: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 5px;
            pointer-events: auto;
        }

        .zoom-btn {
            width: 37px;
            height: 37px;
            border: 1px solid #eee;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #555;
        }

        .zoom-btn:hover {
            background-color: #f0f0f0;
        }

        /* Modals */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }

        .modal {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            display: none;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal.active {
            display: flex;
        }

        #import-textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            font-weight: 500;
        }

        .btn-cancel {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-danger {
            background: var(--delete-color);
            color: white;
        }

        .btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>

<body>

    <div id="header">
        <div id="project-title" contenteditable="true">Organograma sem título</div>
    </div>

    <div id="app-body">
        <div id="sidebar">
            <!-- Style Tools Group -->
            <div class="color-picker-wrapper tool-btn" data-tooltip="Cor de fundo (Background Color)">
                <div class="color-preview" id="bg-preview" style="background-color: #ffffff;">
                    <!-- Icon: Paint Bucket / Fill -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" fill="none">
                        <g stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <!-- outer box -->
                            <rect x="4.5" y="4.5" width="21" height="21" rx="3.5" />

                            <!-- diagonal split (shifted down/left to clear the dot) -->
                            <path d="M5 24 L24 15 V25 Z" fill="currentColor" opacity="0.58" />

                            <!-- color swatch dot -->
                            <circle cx="21.2" cy="8.8" r="2.2" fill="currentColor" stroke="none" />
                        </g>
                    </svg>
                </div>
                <input type="color" id="bg-color-picker" class="color-input" value="#ffffff">
            </div>

            <div class="color-picker-wrapper tool-btn" data-tooltip="Cor da borda (Border Color)">
                <div class="color-preview" id="border-preview" style="border: 2px solid #ccc;">
                    <!-- Icon: Square frame -->
                    <svg viewBox="0 0 24 24">
                        <rect x="4" y="4" width="16" height="16" stroke="black" stroke-width="2" />
                    </svg>
                </div>
                <input type="color" id="border-color-picker" class="color-input" value="#cccccc">
            </div>

            <div class="tool-btn" id="border-width-btn" data-tooltip="Espessura da borda (Border Width)">
                <svg viewBox="0 0 24 24">
                    <path d="M3 12h18" stroke="black" stroke-width="4" stroke-linecap="round" />
                </svg>
                <div id="border-width-popover" class="slider-popover">
                    <input type="range" id="border-width-slider" min="0" max="10" value="2">
                </div>
            </div>

            <div class="divider"></div>

            <!-- Font Tools Group -->
            <div class="color-picker-wrapper tool-btn" data-tooltip="Cor da fonte (Text Color)">
                <div class="color-preview" id="text-color-preview">
                    <!-- Icon: A with red underline -->
                    <svg viewBox="0 0 24 24">
                        <path d="M7 17l5-13 5 13M9 12h6" stroke="black" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" />
                        <path d="M4 21h16" stroke="#ef4444" stroke-width="3" stroke-linecap="round" />
                    </svg>
                </div>
                <input type="color" id="text-color-picker" class="color-input" value="#000000">
            </div>

            <div class="tool-btn" id="font-size-btn" data-tooltip="Tamanho da fonte (Font Size)">
                <!-- Icon: Small A next to Big A -->
                <svg viewBox="0 0 24 24">
                    <text x="4" y="18" font-size="8">A</text>
                    <text x="12" y="18" font-size="16">A</text>
                </svg>
                <div id="font-size-popover" class="slider-popover">
                    <input type="range" id="font-size-slider" min="10" max="40" value="16">
                </div>
            </div>

            <div class="tool-btn" id="format-painter-btn" data-tooltip="Copiar Estilo (Format Painter)">
                <!-- Icon: Paint Roller (Handle + Cylinder) -->
                <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" fill="none">
                    <g stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                        <!-- roller -->
                        <path d="M6 4.8h14.2a2 2 0 0 1 2 2V9a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6.8a2 2 0 0 1 2-2Z" />
                        <!-- bracket -->
                        <path d="M22.2 6.2h2.2v3.4h-2.2" />
                        <!-- arm -->
                        <path d="M24.4 9.6v2.4l-6.8 3.6v2.2" />
                        <!-- handle -->
                        <path
                            d="M14.2 17.8a1.6 1.6 0 0 1 1.6-1.6h2.4a1.6 1.6 0 0 1 1.6 1.6v7.2a1.6 1.6 0 0 1-1.6 1.6h-2.4a1.6 1.6 0 0 1-1.6-1.6Z" />
                        <!-- inner inset -->
                        <path d="M16.0 18.9h2.0v5.0h-2.0Z" />
                    </g>
                </svg>
            </div>

            <div class="divider"></div>

            <!-- Action Tools -->
            <div class="tool-btn" id="delete-btn" data-tooltip="Excluir item (Delete)">
                <svg viewBox="0 0 24 24" stroke="var(--delete-color)">
                    <path
                        d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6" />
                </svg>
            </div>

            <div class="tool-btn" id="reset-view-btn" data-tooltip="Resetar Vista (Reset View)">
                <!-- Icon: Arrows pointing to center/corners -->
                <svg viewBox="0 0 24 24" stroke="black">
                    <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7" />
                </svg>
            </div>

            <div class="divider"></div>

            <div class="tool-btn" id="export-btn" data-tooltip="Exportar JSON (Copy/Export)">
                <!-- Icon: Clipboard with arrow UP/OUT -->
                <svg viewBox="0 0 24 24" stroke="black">
                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
                    <path d="M12 11h4" />
                    <path d="M12 14h4" />
                    <path d="M8 11h1" />
                    <path d="M8 14h1" />
                </svg>
            </div>

            <div class="tool-btn" id="import-btn" data-tooltip="Importar JSON (Paste/Import)">
                <!-- Icon: Clipboard with arrow IN -->
                <svg viewBox="0 0 24 24" stroke="black">
                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
                    <path d="M12 12v6" />
                    <path d="M9 15l3 3 3-3" />
                </svg>
            </div>

        </div>

        <div id="canvas-container">
            <div id="world">
                <div id="grid-pattern"></div>
                <svg id="connections-layer"></svg>
                <div id="nodes-layer"></div>
            </div>
            <div id="zoom-controls">
                <button class="zoom-btn" onclick="zoom(0.1)">+</button>
                <button class="zoom-btn" onclick="resetZoom()">100%</button>
                <button class="zoom-btn" onclick="zoom(-0.1)">-</button>
            </div>
        </div>

        <!-- Modals Overlay -->
        <div id="modal-overlay">

            <!-- Import Modal -->
            <div id="import-modal" class="modal">
                <h3 style="margin: 0;">Importar JSON</h3>
                <p style="margin: 0; color: #666; font-size: 14px;">Cole o JSON abaixo. O conteúdo atual será
                    substituído.
                </p>
                <textarea id="import-textarea" placeholder='[{"id": "node-1", ...}]'></textarea>
                <div class="modal-buttons">
                    <button class="btn btn-cancel" onclick="closeModal()">Cancelar</button>
                    <button class="btn btn-primary" id="btn-confirm-import" disabled>Importar</button>
                </div>
            </div>

            <!-- Generic Confirm Modal -->
            <div id="confirm-modal" class="modal">
                <h3 style="margin: 0;" id="confirm-title">Confirmação</h3>
                <p style="margin: 0; color: #666; font-size: 14px;" id="confirm-message">Are you sure?</p>
                <div class="modal-buttons">
                    <button class="btn btn-cancel" onclick="closeModal()">Não</button>
                    <button class="btn btn-primary" id="btn-confirm-yes">Sim</button>
                </div>
            </div>

            <!-- Generic Alert Modal -->
            <div id="alert-modal" class="modal">
                <h3 style="margin: 0;" id="alert-title">Aviso</h3>
                <p style="margin: 0; color: #666; font-size: 14px;" id="alert-message">Info</p>
                <div class="modal-buttons">
                    <button class="btn btn-primary" onclick="closeModal()">OK</button>
                </div>
            </div>

        </div>

        <script>
            const canvasContainer = document.getElementById('canvas-container');
            const world = document.getElementById('world');
            const nodesLayer = document.getElementById('nodes-layer');
            const connectionsLayer = document.getElementById('connections-layer');
            const modalOverlay = document.getElementById('modal-overlay');

            // State variables
            let projectTitle = "Organograma sem título";
            let nodes = [];
            let selectedNodeId = null;
            let isNodeDragging = false;
            let isSubtreeDrag = false;
            let isResizing = false;
            let isPanning = false;
            let dragOffset = { x: 0, y: 0 };
            let resizeStart = { x: 0, y: 0, w: 0, h: 0 };
            let resizeType = ''; // 'r', 'b', 'rb'
            let panStart = { x: 0, y: 0 };
            let draggedNodeId = null;
            let draggedSubtreeIds = [];
            let resizingNodeId = null;
            let viewState = { x: 0, y: 0, scale: 1 };

            // Format Painter State
            let formatPainterMode = 'IDLE'; // IDLE, SINGLE, CONTINUOUS
            let formatSourceStyle = null;

            // Persistent Style (Last used style)
            let currentStyle = {
                backgroundColor: '#ffffff',
                borderColor: '#cccccc',
                borderWidth: 2,
                fontSize: 16,
                color: '#000000'
            };

            const DEFAULT_TEXT = "<texto>";
            const CHILD_OFFSET_Y = 150;
            const CHILD_SPACING_X = 160;

            // --- Core ---

            function init() {
                // Set initial view
                resetViewPosition();

                // Initial Node
                createNode({ x: 0, y: 0, text: DEFAULT_TEXT, isRoot: true });
                render();
                setupEventListeners();

                // Ensure initial center positioning
                requestAnimationFrame(() => {
                    resetViewPosition();
                });
            }

            function resetViewPosition() {
                const rootNode = nodes.find(n => !n.parentId) || nodes[0];
                if (!rootNode) return;

                const el = document.getElementById(rootNode.id);
                const nodeWidth = el ? el.offsetWidth : 180;
                const nodeHeight = el ? el.offsetHeight : 80;

                const sidebarWidth = 60;
                const headerHeight = 60;

                // Target absolute horizontal center (window center) relative to canvas container
                const centerX = (window.innerWidth / 2) - sidebarWidth;

                // We want the node's top to be some distance below the header
                const targetY = headerHeight + 50;

                viewState.scale = 1;
                viewState.x = centerX - (rootNode.x + nodeWidth / 2);
                viewState.y = targetY - rootNode.y;

                updateWorldTransform();
            }

            function createNode({ x, y, title = "<Título>", text = DEFAULT_TEXT, parentId = null, isRoot = false, id = null, style = null, width = 180, height = 100 }) {
                const nodeId = id || 'node-' + Date.now() + '-' + Math.floor(Math.random() * 1000);

                // Use provided style or clone current persistent style
                const nodeStyle = style ? { ...style } : { ...currentStyle };

                const newNode = {
                    id: nodeId,
                    x,
                    y,
                    width: width,
                    height: height,
                    title,
                    text,
                    parentId,
                    style: nodeStyle
                };
                nodes.push(newNode);
                render();
                if (!id) selectNode(nodeId);
                return nodeId;
            }

            function deleteNode(id) {
                showConfirm("Excluir Item", "Tem certeza que deseja excluir este item e seus filhos?", () => {
                    const toDelete = [id];
                    let i = 0;
                    while (i < toDelete.length) {
                        const currentId = toDelete[i];
                        const children = nodes.filter(n => n.parentId === currentId);
                        children.forEach(c => toDelete.push(c.id));
                        i++;
                    }

                    nodes = nodes.filter(n => !toDelete.includes(n.id));
                    selectedNodeId = null;
                    render();
                    updateToolbarFromSelection();
                });
            }

            function updateNodeStyle(id, styleUpdate) {
                const node = nodes.find(n => n.id === id);
                if (node) {
                    node.style = { ...node.style, ...styleUpdate };
                    // Update persistent style when user actively changes something
                    currentStyle = { ...currentStyle, ...styleUpdate };
                    render();
                }
            }

            function updateNodeText(id, newText) {
                const node = nodes.find(n => n.id === id);
                if (node) {
                    node.text = newText;
                }
            }

            function updateNodeTitle(id, newTitle) {
                const node = nodes.find(n => n.id === id);
                if (node) {
                    node.title = newTitle;
                }
            }

            function updateNodePosition(id, x, y) {
                const node = nodes.find(n => n.id === id);
                if (node) {
                    node.x = x;
                    node.y = y;
                    const el = document.getElementById(id);
                    if (el) {
                        el.style.left = x + 'px';
                        el.style.top = y + 'px';
                    }
                    updateConnections();
                }
            }

            // --- View & Render ---

            function render() {
                // Sync DOM
                const existingIds = Array.from(nodesLayer.children).map(el => el.id);
                const currentIds = nodes.map(n => n.id);

                existingIds.forEach(id => {
                    if (!currentIds.includes(id)) {
                        document.getElementById(id).remove();
                    }
                });

                nodes.forEach(node => {
                    let el = document.getElementById(node.id);
                    if (!el) {
                        el = document.createElement('div');
                        el.id = node.id;
                        el.className = 'node';
                        el.innerHTML = `
                        <div class="node-title-bar">
                            <div class="node-title" contenteditable="false"></div>
                        </div>
                        <div class="node-content" contenteditable="false"></div>
                        <div class="add-child-btn" title="Adicionar filho">+</div>
                        <div class="resizer resizer-r" data-type="r"></div>
                        <div class="resizer resizer-b" data-type="b"></div>
                        <div class="resizer resizer-rb" data-type="rb"></div>
                    `;

                        const titleEl = el.querySelector('.node-title');
                        const contentEl = el.querySelector('.node-content');

                        // Interaction for Body
                        contentEl.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            contentEl.contentEditable = true;
                            el.classList.add('editing');
                            contentEl.focus();
                            document.execCommand('selectAll', false, null);
                        });

                        contentEl.addEventListener('blur', (e) => {
                            contentEl.contentEditable = false;
                            el.classList.remove('editing');
                            updateNodeText(node.id, contentEl.innerText);
                            requestAnimationFrame(updateConnections);
                        });

                        contentEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                // Default behavior for Enter in contenteditable is newline
                                // but we might want to ensure it's just a newline and doesn't blur
                                e.stopPropagation();
                            }
                        });

                        // Interaction for Title
                        titleEl.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            titleEl.contentEditable = true;
                            el.classList.add('editing');
                            titleEl.focus();
                            document.execCommand('selectAll', false, null);
                        });

                        titleEl.addEventListener('blur', (e) => {
                            titleEl.contentEditable = false;
                            el.classList.remove('editing');
                            updateNodeTitle(node.id, titleEl.innerText);
                        });

                        titleEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault(); // Don't allow newlines in title
                            }
                        });

                        el.addEventListener('mousedown', (e) => {
                            if (el.classList.contains('editing')) return;
                            e.stopPropagation();

                            // Handle Format Painter Click
                            if (formatPainterMode !== 'IDLE') {
                                handleFormatPainterApply(node);
                                return;
                            }

                            selectNode(node.id);
                            startNodeDrag(e, node);
                        });

                        el.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                        });

                        // Add button
                        const addBtn = el.querySelector('.add-child-btn');
                        addBtn.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            addChildTo(node.id);
                        });

                        // Resize Listeners
                        el.querySelectorAll('.resizer').forEach(resizer => {
                            resizer.addEventListener('mousedown', (e) => {
                                e.stopPropagation();
                                startNodeResize(e, node, resizer.dataset.type);
                            });
                        });

                        nodesLayer.appendChild(el);
                    }

                    // Style Application
                    el.style.left = node.x + 'px';
                    el.style.top = node.y + 'px';
                    el.style.width = node.width + 'px';
                    el.style.height = node.height + 'px';
                    el.style.backgroundColor = node.style.backgroundColor;
                    el.style.borderColor = node.style.borderColor;
                    el.style.borderWidth = node.style.borderWidth + 'px';

                    const titleBarEl = el.querySelector('.node-title-bar');
                    const titleEl = el.querySelector('.node-title');
                    const contentEl = el.querySelector('.node-content');

                    // Apply Derived Styling to Title Bar
                    titleBarEl.style.backgroundColor = node.style.color;
                    titleBarEl.style.borderBottom = `${node.style.borderWidth}px solid ${node.style.borderColor}`;

                    if (document.activeElement !== titleEl && titleEl.innerText !== (node.title || "<Título>")) {
                        titleEl.innerText = node.title || "<Título>";
                    }
                    titleEl.style.color = node.style.backgroundColor;
                    titleEl.style.fontSize = (parseInt(node.style.fontSize) + 2) + 'px';

                    if (document.activeElement !== contentEl && contentEl.innerText !== node.text) {
                        contentEl.innerText = node.text;
                    }
                    contentEl.style.color = node.style.color;
                    contentEl.style.fontSize = node.style.fontSize + 'px';

                    if (node.id === selectedNodeId) {
                        el.classList.add('selected');
                    } else {
                        el.classList.remove('selected');
                    }
                });

                updateConnections();
            }

            function updateConnections() {
                connectionsLayer.innerHTML = '';

                nodes.forEach(node => {
                    if (node.parentId) {
                        const parent = nodes.find(n => n.id === node.parentId);
                        if (parent) {
                            drawLine(parent, node);
                        }
                    }
                });
            }

            function drawLine(startNode, endNode) {
                const startEl = document.getElementById(startNode.id);
                const endEl = document.getElementById(endNode.id);
                if (!startEl || !endEl) return;

                const startW = startEl.offsetWidth;
                const startH = startEl.offsetHeight;
                const endW = endEl.offsetWidth;
                const endH = endEl.offsetHeight;

                const x1 = startNode.x + startW / 2;
                const y1 = startNode.y + startH / 2;
                const x2 = endNode.x + endW / 2;
                const y2 = endNode.y + endH / 2;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'connection-line');

                const d = `M ${x1} ${y1} C ${x1} ${y1 + 50}, ${x2} ${y2 - 50}, ${x2} ${y2}`;
                path.setAttribute('d', d);
                connectionsLayer.appendChild(path);
            }

            function updateWorldTransform() {
                world.style.transform = `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`;
            }

            // --- Interaction Logic ---

            function zoom(delta) {
                viewState.scale += delta;
                if (viewState.scale < 0.1) viewState.scale = 0.1;
                updateWorldTransform();
            }

            function resetZoom() {
                viewState.scale = 1;
                updateWorldTransform();
            }

            function selectNode(id) {
                selectedNodeId = id;
                nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (el) {
                        if (n.id === id) el.classList.add('selected');
                        else el.classList.remove('selected');
                    }
                });
                updateToolbarFromSelection();

                // If selecting a node, we might want to update currentStyle to match selection
                // so next created node matches this one? User requirement says:
                // "Faça a última configuração de estilo (borda, fonte, etc) persistir para o próximo nó criado"
                // Usually this means if I change a setting. Does selecting change the "pen"?
                // Let's assume selection sets current style context.
                const node = nodes.find(n => n.id === id);
                if (node) {
                    currentStyle = { ...node.style };
                }
            }

            function deselectAll() {
                selectedNodeId = null;
                document.querySelectorAll('.node.selected').forEach(el => el.classList.remove('selected'));
                updateToolbarFromSelection();
            }

            function addChildTo(parentId) {
                const parent = nodes.find(n => n.id === parentId);
                if (!parent) return;

                const children = nodes.filter(n => n.parentId === parentId);
                const childY = parent.y + parent.height + 60; // Standard vertical gap

                let childX;
                if (children.length > 0) {
                    // Place to the right of the rightmost child
                    const rightmostChild = children.reduce((prev, curr) => (curr.x + curr.width > prev.x + prev.width) ? curr : prev);
                    childX = rightmostChild.x + rightmostChild.width + 40; // 40px horizontal gap
                } else {
                    // Center the first child below the parent
                    childX = parent.x + (parent.width / 2) - 90; // (90 is half of default 180 width)
                }

                // Smart Placement (Horizontal shifts to avoid any overlap)
                let attempts = 0;
                while (isOverlapping(childX, childY) && attempts < 25) {
                    childX += 50; // Shift right until it fits
                    attempts++;
                }

                createNode({ x: childX, y: childY, parentId: parentId });
            }

            function isOverlapping(x, y) {
                return nodes.some(n => Math.abs(n.x - x) < 50 && Math.abs(n.y - y) < 50);
            }

            // --- Dragging ---

            function startNodeDrag(e, node) {
                isNodeDragging = true;
                draggedNodeId = node.id;
                isSubtreeDrag = (e.button === 2 || (e.button === 0 && e.shiftKey)); // Right click or Shift+Left

                if (isSubtreeDrag) {
                    draggedSubtreeIds = getSubtreeIds(node.id);
                } else {
                    draggedSubtreeIds = [];
                }

                const mouseWorldX = (e.clientX - viewState.x) / viewState.scale;
                const mouseWorldY = (e.clientY - viewState.y) / viewState.scale;

                dragOffset.x = mouseWorldX - node.x;
                dragOffset.y = mouseWorldY - node.y;

                document.body.style.cursor = 'grabbing';
            }

            function getSubtreeIds(nodeId) {
                let ids = [nodeId];
                nodes.filter(n => n.parentId === nodeId).forEach(child => {
                    ids = ids.concat(getSubtreeIds(child.id));
                });
                return ids;
            }

            function startNodeResize(e, node, type) {
                isResizing = true;
                resizingNodeId = node.id;
                resizeType = type;

                const mouseWorldX = (e.clientX - viewState.x) / viewState.scale;
                const mouseWorldY = (e.clientY - viewState.y) / viewState.scale;

                resizeStart.x = mouseWorldX;
                resizeStart.y = mouseWorldY;
                resizeStart.w = node.width;
                resizeStart.h = node.height;

                let cursor = 'nwse-resize';
                if (type === 'r') cursor = 'col-resize';
                if (type === 'b') cursor = 'row-resize';
                document.body.style.cursor = cursor;
            }

            function startPan(e) {
                isPanning = true;
                panStart.x = e.clientX - viewState.x;
                panStart.y = e.clientY - viewState.y;
                canvasContainer.style.cursor = 'grabbing';

                // If in format painter mode, cancel it on background click?
                // "aplica enquanto o usuario não clicar no background" (for double click)
                if (formatPainterMode === 'CONTINUOUS') {
                    setFormatPainterMode('IDLE');
                }
            }

            function stopDrag() {
                isNodeDragging = false;
                isResizing = false;
                isPanning = false;
                draggedNodeId = null;
                resizingNodeId = null;
                document.body.style.cursor = 'default';
                // maintain cursor if format painter
                if (formatPainterMode !== 'IDLE') {
                    // css handles cursor
                } else {
                    canvasContainer.style.cursor = 'grab';
                }
            }

            // --- Format Painter ---

            function handleFormatPainterClick() {
                if (!selectedNodeId) {
                    showAlert("Aviso", "Selecione um nó primeiro para copiar o estilo.");
                    return;
                }

                const node = nodes.find(n => n.id === selectedNodeId);
                formatSourceStyle = { ...node.style };

                // Logic for single vs double click handled by caller or state?
                // Caller: onclick vs ondblclick.
                // If single click, set mode SINGLE.
                // If double, set mode CONTINUOUS.
                // But we need to distinguish.
            }

            function setFormatPainterMode(mode) {
                formatPainterMode = mode;
                const btn = document.getElementById('format-painter-btn');
                if (mode === 'IDLE') {
                    btn.classList.remove('active');
                    document.body.classList.remove('format-painter-mode');
                } else {
                    btn.classList.add('active');
                    document.body.classList.add('format-painter-mode');
                }
            }

            function handleFormatPainterApply(targetNode) {
                if (!formatSourceStyle) return;

                updateNodeStyle(targetNode.id, formatSourceStyle);

                if (formatPainterMode === 'SINGLE') {
                    setFormatPainterMode('IDLE');
                }
            }


            // --- Listeners ---

            function setupEventListeners() {
                canvasContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    zoom(e.deltaY > 0 ? -0.1 : 0.1);
                });

                canvasContainer.addEventListener('mousedown', (e) => {
                    // Only left-click or middle-click on BG pans
                    if (e.button !== 0 && e.button !== 1) return;

                    // If special click on BG
                    if (e.target === canvasContainer || e.target === world || e.target === connectionsLayer || e.target.id === 'grid-pattern') {
                        deselectAll();
                        startPan(e);
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (isNodeDragging && draggedNodeId) {
                        const mouseWorldX = (e.clientX - viewState.x) / viewState.scale;
                        const mouseWorldY = (e.clientY - viewState.y) / viewState.scale;

                        const newX = mouseWorldX - dragOffset.x;
                        const newY = mouseWorldY - dragOffset.y;

                        if (isSubtreeDrag) {
                            const node = nodes.find(n => n.id === draggedNodeId);
                            const deltaX = newX - node.x;
                            const deltaY = newY - node.y;

                            if (deltaX !== 0 || deltaY !== 0) {
                                draggedSubtreeIds.forEach(id => {
                                    const n = nodes.find(item => item.id === id);
                                    if (n) {
                                        n.x += deltaX;
                                        n.y += deltaY;
                                        const el = document.getElementById(id);
                                        if (el) {
                                            el.style.left = n.x + 'px';
                                            el.style.top = n.y + 'px';
                                        }
                                    }
                                });
                                updateConnections();
                            }
                        } else {
                            updateNodePosition(draggedNodeId, newX, newY);
                        }
                    } else if (isResizing && resizingNodeId) {
                        const node = nodes.find(n => n.id === resizingNodeId);
                        if (!node) return;

                        const mouseWorldX = (e.clientX - viewState.x) / viewState.scale;
                        const mouseWorldY = (e.clientY - viewState.y) / viewState.scale;

                        const deltaX = mouseWorldX - resizeStart.x;
                        const deltaY = mouseWorldY - resizeStart.y;

                        if (resizeType.includes('r')) {
                            node.width = Math.max(100, resizeStart.w + deltaX);
                        }
                        if (resizeType.includes('b')) {
                            node.height = Math.max(50, resizeStart.h + deltaY);
                        }

                        const el = document.getElementById(node.id);
                        if (el) {
                            el.style.width = node.width + 'px';
                            el.style.height = node.height + 'px';
                        }
                        updateConnections();
                    } else if (isPanning) {
                        viewState.x = e.clientX - panStart.x;
                        viewState.y = e.clientY - panStart.y;
                        updateWorldTransform();
                    }
                });

                window.addEventListener('mouseup', stopDrag);

                // -- Toolbar Inputs --

                const bgPicker = document.getElementById('bg-color-picker');
                bgPicker.addEventListener('input', (e) => {
                    if (selectedNodeId) {
                        updateNodeStyle(selectedNodeId, { backgroundColor: e.target.value });
                        document.getElementById('bg-preview').style.backgroundColor = e.target.value;
                    }
                });

                const borderPicker = document.getElementById('border-color-picker');
                borderPicker.addEventListener('input', (e) => {
                    if (selectedNodeId) {
                        updateNodeStyle(selectedNodeId, { borderColor: e.target.value });
                        document.getElementById('border-preview').style.borderColor = e.target.value;
                    }
                });

                const textPicker = document.getElementById('text-color-picker');
                textPicker.addEventListener('input', (e) => {
                    if (selectedNodeId) {
                        updateNodeStyle(selectedNodeId, { color: e.target.value });
                    }
                });

                const borderWidthBtn = document.getElementById('border-width-btn');
                const borderWidthSlider = document.getElementById('border-width-slider');
                borderWidthBtn.addEventListener('click', (e) => {
                    // Prevent closing if clicking slider
                    if (e.target !== borderWidthSlider) {
                        toggleSlider('border-width-popover', borderWidthBtn);
                    }
                });
                borderWidthSlider.addEventListener('input', (e) => updateNodeStyle(selectedNodeId, { borderWidth: e.target.value }));

                const fontSizeBtn = document.getElementById('font-size-btn');
                const fontSizeSlider = document.getElementById('font-size-slider');
                fontSizeBtn.addEventListener('click', (e) => {
                    if (e.target !== fontSizeSlider) {
                        toggleSlider('font-size-popover', fontSizeBtn);
                    }
                });
                fontSizeSlider.addEventListener('input', (e) => updateNodeStyle(selectedNodeId, { fontSize: e.target.value }));

                // Format Painter
                const fpBtn = document.getElementById('format-painter-btn');
                // Detect single vs double click
                let clickTimer = null;
                fpBtn.addEventListener('click', (e) => {
                    if (clickTimer) {
                        clearTimeout(clickTimer);
                        clickTimer = null;
                        // Double Click logic
                        handleFormatPainterClick();
                        setFormatPainterMode('CONTINUOUS');
                    } else {
                        clickTimer = setTimeout(() => {
                            clickTimer = null;
                            // Single Click logic
                            handleFormatPainterClick();
                            setFormatPainterMode('SINGLE');
                        }, 250);
                    }
                });

                document.getElementById('delete-btn').addEventListener('click', () => {
                    if (selectedNodeId) deleteNode(selectedNodeId);
                });

                document.getElementById('reset-view-btn').addEventListener('click', () => {
                    resetViewPosition();
                });

                document.getElementById('export-btn').addEventListener('click', () => {
                    const data = JSON.stringify({
                        title: projectTitle,
                        nodes: nodes
                    }, null, 2);
                    navigator.clipboard.writeText(data).then(() => {
                        showAlert("Exportar", "Dados exportados para a área de transferência!");
                    });
                });

                document.getElementById('import-btn').addEventListener('click', () => {
                    showModal('import-modal');
                    document.getElementById('import-textarea').value = '';
                    document.getElementById('import-textarea').focus();
                });

                // Import logic
                const btnConfirmImport = document.getElementById('btn-confirm-import');
                const importTextarea = document.getElementById('import-textarea');
                importTextarea.addEventListener('input', (e) => {
                    try {
                        const json = JSON.parse(e.target.value);
                        const isValid = Array.isArray(json) || (json.nodes && Array.isArray(json.nodes));
                        btnConfirmImport.disabled = !isValid;
                    } catch (err) {
                        btnConfirmImport.disabled = true;
                    }
                });

                btnConfirmImport.addEventListener('click', () => {
                    try {
                        const json = JSON.parse(importTextarea.value);
                        let importedNodes = [];
                        if (Array.isArray(json)) {
                            importedNodes = json;
                            projectTitle = "Organograma Importado";
                        } else if (json.nodes && Array.isArray(json.nodes)) {
                            importedNodes = json.nodes;
                            projectTitle = json.title || "Organograma Importado";
                        }

                        if (importedNodes.length > 0 || Array.isArray(json)) {
                            nodes = [];
                            document.getElementById('project-title').innerText = projectTitle;
                            importedNodes.forEach(n => createNode({ ...n, id: n.id, style: n.style }));
                            closeModal();
                            deselectAll();
                        }
                    } catch (e) {
                        showAlert('Erro', 'Erro ao importar JSON.');
                    }
                });

                // Title Sync
                const titleEl = document.getElementById('project-title');
                titleEl.addEventListener('blur', () => {
                    projectTitle = titleEl.innerText;
                });

                // Hide sliders on click outside
                document.addEventListener('mousedown', (e) => {
                    // Close sliders
                    if (!borderWidthBtn.contains(e.target)) closePopover('border-width-popover', borderWidthBtn);
                    if (!fontSizeBtn.contains(e.target)) closePopover('font-size-popover', fontSizeBtn);
                });
            }

            function toggleSlider(id, btn) {
                const popover = document.getElementById(id);
                const isVisible = popover.style.display === 'block';

                // Close others 
                document.querySelectorAll('.slider-popover').forEach(p => p.style.display = 'none');
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('slider-open'));

                if (!isVisible) {
                    popover.style.display = 'block';
                    btn.classList.add('slider-open'); // Helps hide tooltip
                }
            }

            function closePopover(id, btn) {
                document.getElementById(id).style.display = 'none';
                btn.classList.remove('slider-open');
            }

            function updateToolbarFromSelection() {
                const bgInput = document.getElementById('bg-color-picker');
                const bgPreview = document.getElementById('bg-preview');
                const borderInput = document.getElementById('border-color-picker');
                const borderPreview = document.getElementById('border-preview');
                const textInput = document.getElementById('text-color-picker');
                const widthSlider = document.getElementById('border-width-slider');
                const fontSlider = document.getElementById('font-size-slider');

                const style = selectedNodeId ? nodes.find(n => n.id === selectedNodeId).style : currentStyle;

                bgInput.value = style.backgroundColor;
                bgPreview.style.backgroundColor = style.backgroundColor;

                borderInput.value = style.borderColor;
                borderPreview.style.borderColor = style.borderColor;

                textInput.value = style.color;

                widthSlider.value = style.borderWidth;
                fontSlider.value = style.fontSize;
            }

            // --- Modal System ---

            function showModal(id) {
                modalOverlay.style.display = 'flex';
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
                document.getElementById(id).classList.add('active');
            }

            function closeModal() {
                modalOverlay.style.display = 'none';
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
            }

            function showAlert(title, message) {
                document.getElementById('alert-title').innerText = title;
                document.getElementById('alert-message').innerText = message;
                showModal('alert-modal');
            }

            function showConfirm(title, message, onConfirm) {
                document.getElementById('confirm-title').innerText = title;
                document.getElementById('confirm-message').innerText = message;

                const yesBtn = document.getElementById('btn-confirm-yes');
                // Remove old listeners to avoid stacking
                const newBtn = yesBtn.cloneNode(true);
                yesBtn.parentNode.replaceChild(newBtn, yesBtn);

                newBtn.addEventListener('click', () => {
                    onConfirm();
                    closeModal();
                });
                newBtn.classList.add('btn-danger'); // Style for delete mostly

                showModal('confirm-modal');
            }

            // --- Start ---
            init();

        </script>
</body>

</html>